service: poc-${self:custom.user}

plugins:
  - serverless-mocha-plugin
  - serverless-dynamodb-local
  - serverless-offline

custom:
  # This can be changed to the desired origin
  # When using lambda proxy integration, you have to manually add the CORS headers to responses...
  # https://github.com/serverless/serverless/issues/4681
  corsOrigin: '*'
  user: ${env:USER}
  dynamodb:
    stages:
      - dev
      - test
    start:
      port: 8000
      # dbPath: .dynamodb/data
      migrate: true
      seed: true
    seed:
      test:
        sources:
          - table: ${self:provider.environment.DYNAMODB_CASE_DEFINITIONS_TABLE}
            sources: [./data/case-definitions-with-id.json]
          - table: ${self:provider.environment.DYNAMODB_TASK_DEFINITIONS_TABLE}
            sources: [./data/task-definitions-with-id.json]
  serverless-offline:
    httpsProtocol: "certs"
    port: 3000
  splitStacks:
    perFunction: false
    perType: true
    perGroupFunction: false

# This article helped me find out how Serverless handles Cloud Formation naming
# https://github.com/serverless/serverless/blob/master/docs/providers/aws/guide/resources.md
provider:
  name: aws
  memorySize: 256
  runtime: nodejs12.x
  region: ${opt:region, 'us-east-1'}
  stage: ${opt:stage, 'dev'}
  # API GW Websocket specific configuration
  websocketsApiName: ${self:service}-apigw-websocket-${self:provider.stage}
  # Custom routes are selected by the value of the action property in the body
  websocketsApiRouteSelectionExpression: $request.body.action
  # DynamoDB table name, as composed with parameters from this definition file
  environment:
    ENVIRONMENT: ${self:provider.stage}
    # COGNITO_USER_POOL:
    #   Ref: CognitoUserPool
    # COGNITO_USER_POOL_CLIENT:
    #   Ref: CognitoUserPoolClient
    CORS_ORIGIN: ${self:custom.corsOrigin}
    DYNAMODB_SOCKETS_TABLE: ${self:service}-sockets-${self:provider.stage}
    DYNAMODB_SOCKETS_USER_GSI: ${self:service}-sockets-user-gsi-${self:provider.stage}
    DYNAMODB_CASE_DEFINITIONS_TABLE: ${self:service}-case-definitions-${self:provider.stage}
    DYNAMODB_TASK_DEFINITIONS_TABLE: ${self:service}-task-definitions-${self:provider.stage}
    DYNAMODB_CASES_TABLE: ${self:service}-cases-${self:provider.stage}
    DYNAMODB_CASES_ON_STATE_GSI: ${self:service}-cases-on-state-gsi-${self:provider.stage}
    DYNAMODB_TASKS_TABLE: ${self:service}-tasks-${self:provider.stage}
    DYNAMODB_TASKS_ON_CASE_GSI: ${self:service}-tasks-on-case-gsi-${self:provider.stage}
    DYNAMODB_TASKS_ON_STATE_GSI: ${self:service}-tasks-on-state-gsi-${self:provider.stage}
    DYNAMODB_CASE_MESSAGES_TABLE: ${self:service}-case-messages-${self:provider.stage}
    DYNAMODB_CASE_MESSAGES_CASEID_GSI: ${self:service}-case-messages-caseid-gsi-${self:provider.stage}
    # KEYS_URL: !Join ['', ['https://cognito-idp.', '${self:provider.region}', '.amazonaws.com/', !Ref CognitoUserPool, '/.well-known/jwks.json']]
    WEBSOCKET_API_ENDPOINT: !Join ['', ['https://', !Ref WebsocketsApi, '.execute-api.', '${self:provider.region}', '.amazonaws.com/', '${self:provider.stage}/']]
  # Define the service IAM permissions
  iamRoleStatements:
    # Websocket permissions
    - Effect: Allow
      Action:
        - "execute-api:ManageConnections"
      Resource:
        - "arn:aws:execute-api:${self:provider.region}:*:**/@connections/*"
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource:
        # TODO: be more specific to this service
        - "arn:aws:dynamodb:${self:provider.region}:*:table/*"

functions:
  # authUser:
  #   name: LAMBDA_${self:service}_auth_${self:provider.stage}
  #   handler: handler.authUser
  #   events:
  #     - http:
  #         path: auth
  #         method: post
  #         cors:
  #           origin: ${self:custom.corsOrigin}
  # authWebsocket:
  #   name: LAMBDA_${self:service}_auth_websocket_${self:provider.stage}
  #   handler: handler.authWebsocket
  #   cors:
  #     origin: ${self:custom.corsOrigin}
  # refreshToken:
  #   name: LAMBDA_${self:service}_auth_refresh_${self:provider.stage}
  #   handler: handler.refreshToken
  #   events:
  #     - http:
  #         path: auth/refresh
  #         method: post
  #         cors:
  #           origin: ${self:custom.corsOrigin}
  handleSocketDefault:
    name: LAMBDA_${self:service}_socket_default_${self:provider.stage}
    handler: handler.handleSocketDefault
    events:
      - websocket:
          route: $default
  handleSocketConnect:
    name: LAMBDA_${self:service}_socket_connect_${self:provider.stage}
    handler: handler.handleSocketConnect
    events:
      - websocket:
          route: $connect
          # references the authWebsocket function below, serverless doesn't provide any other
          # way to perform this as of 01/07/2019
          # authorizer:
          #   name: authWebsocket
          #   identitySource:
          #     - 'route.request.querystring.Authorizer'
  handleSocketDisconnect:
    name: LAMBDA_${self:service}_socket_disconnect_${self:provider.stage}
    handler: handler.handleSocketDisconnect
    events:
      - websocket:
          route: $disconnect
  # handleSocketInteraction:
  #   name: LAMBDA_${self:service}_socket_interaction_${self:provider.stage}
  #   handler: handler.handleSocketInteraction
  #   events:
  #     - websocket:
  #         route: interaction
  webhook:
    name: LAMBDA_${self:service}_http_webhook_${self:provider.stage}
    handler: handler.webhook
    events:
      - http:
          path: webhook
          method: post
          cors: true
  createCaseDefinition:
    name: LAMBDA_${self:service}_http_create_case_definition_${self:provider.stage}
    handler: handler.createCaseDefinition
    events:
      - http:
          path: case-definitions
          method: post
          cors:
            origin: ${self:custom.corsOrigin}
  getCaseDefinition:
    name: LAMBDA_${self:service}_http_get_case_definition_${self:provider.stage}
    handler: handler.getCaseDefinition
    events:
      - http:
          path: case-definitions/{caseDefinitionId}
          method: get
          request:
            parameters:
              paths:
                caseDefinitionId: true
          cors: true
  listCaseDefinitions:
    name: LAMBDA_${self:service}_http_list_case_definitions_${self:provider.stage}
    handler: handler.listCaseDefinitions
    events:
      - http:
          path: case-definitions
          method: get
          cors: true
  deleteCaseDefinition:
    name: LAMBDA_${self:service}_http_delete_case_definition_${self:provider.stage}
    handler: handler.deleteCaseDefinition
    events:
      - http:
          path: case-definitions/{caseDefinitionId}
          method: delete
          request:
            parameters:
              paths:
                caseDefinitionId: true
          cors: true
  createTaskDefinition:
    name: LAMBDA_${self:service}_http_create_task_definition_${self:provider.stage}
    handler: handler.createTaskDefinition
    events:
      - http:
          path: task-definitions
          method: post
          cors:
            origin: ${self:custom.corsOrigin}
  getTaskDefinition:
    name: LAMBDA_${self:service}_http_get_task_definition_${self:provider.stage}
    handler: handler.getTaskDefinition
    events:
      - http:
          path: task-definitions/{taskDefinitionId}
          method: get
          request:
            parameters:
              paths:
                taskDefinitionId: true
          cors: true
  listTaskDefinitions:
    name: LAMBDA_${self:service}_http_list_task_definitions_${self:provider.stage}
    handler: handler.listTaskDefinitions
    events:
      - http:
          path: task-definitions
          method: get
          cors: true
  deleteTaskDefinition:
    name: LAMBDA_${self:service}_http_delete_task_definition_${self:provider.stage}
    handler: handler.deleteTaskDefinition
    events:
      - http:
          path: task-definitions/{taskDefinitionId}
          method: delete
          request:
            parameters:
              paths:
                taskDefinitionId: true
          cors: true
  createCase:
    name: LAMBDA_${self:service}_http_create_case_${self:provider.stage}
    handler: handler.createCase
    events:
      - http:
          path: cases
          method: post
          cors:
            origin: ${self:custom.corsOrigin}
  getCase:
    name: LAMBDA_${self:service}_http_get_case_${self:provider.stage}
    handler: handler.getCase
    events:
      - http:
          path: cases/{caseId}
          method: get
          request:
            parameters:
              paths:
                caseId: true
          cors: true
  listCases:
    name: LAMBDA_${self:service}_http_list_cases_${self:provider.stage}
    handler: handler.listCases
    events:
      - http:
          path: cases
          method: get
          cors: true
  addCaseParticipant:
    name: LAMBDA_${self:service}_add_case_participant_${self:provider.stage}
    handler: handler.addCaseParticipant
    events:
      - http:
          path: cases/{caseId}/add-participant/{username}
          method: patch
          request:
            parameters:
              path:
                caseId: true
                username: true
          cors: true
  completeCase:
    name: LAMBDA_${self:service}_http_complete_case_${self:provider.stage}
    handler: handler.completeCase
    events:
      - http:
          path: cases/{caseId}
          method: patch
          request:
            parameters:
              paths:
                caseId: true
          cors: true
  deleteCase:
    name: LAMBDA_${self:service}_http_delete_case_${self:provider.stage}
    handler: handler.deleteCase
    events:
      - http:
          path: cases/{caseId}
          method: delete
          request:
            parameters:
              paths:
                caseId: true
          cors: true

  createTask:
    name: LAMBDA_${self:service}_http_create_task_${self:provider.stage}
    handler: handler.createTask
    events:
      - http:
          path: cases/{caseId}/tasks
          method: post
          request:
            parameters:
              paths:
                caseId: true
          cors:
            origin: ${self:custom.corsOrigin}
  getTask:
    name: LAMBDA_${self:service}_http_get_task_${self:provider.stage}
    handler: handler.getTask
    events:
      - http:
          path: tasks/{taskId}
          method: get
          request:
            parameters:
              paths:
                taskId: true
          cors: true
      - http:
          path: cases/{caseId}/tasks/{taskId}
          method: get
          request:
            parameters:
              paths:
                caseId: true
                taskId: true
          cors: true
  listTasks:
    name: LAMBDA_${self:service}_http_list_tasks_${self:provider.stage}
    handler: handler.listTasks
    events:
      - http:
          path: tasks
          method: get
          cors: true
      - http:
          path: cases/{caseId}/tasks
          method: get
          request:
            parameters:
              paths:
                caseId: true
          cors: true
  completeTask:
    name: LAMBDA_${self:service}_http_complete_task_${self:provider.stage}
    handler: handler.completeTask
    events:
      - http:
          path: tasks/{taskId}/complete
          method: patch
          request:
            parameters:
              paths:
                taskId: true
          cors: true
      - http:
          path: cases/{caseId}/tasks/{taskId}/complete
          method: patch
          request:
            parameters:
              paths:
                caseId: true
                taskId: true
          cors: true
  deleteTask:
    name: LAMBDA_${self:service}_http_delete_task_${self:provider.stage}
    handler: handler.deleteTask
    events:
      - http:
          path: tasks/{taskId}
          method: delete
          request:
            parameters:
              paths:
                taskId: true
          cors: true

  createCaseMessage:
    name: LAMBDA_${self:service}_http_create_case_message_${self:provider.stage}
    handler: handler.createCaseMessage
    events:
      - http:
          path: case-messages
          method: post
          cors:
            origin: ${self:custom.corsOrigin}
  getCaseMessage:
    name: LAMBDA_${self:service}_http_get_case_message_${self:provider.stage}
    handler: handler.getCaseMessage
    events:
      - http:
          path: case-messages/{caseMessageId}
          method: get
          request:
            parameters:
              paths:
                caseMessageId: true
          cors: true
  listCaseMessages:
    name: LAMBDA_${self:service}_http_list_case_messages_${self:provider.stage}
    handler: handler.listCaseMessages
    events:
      - http:
          path: case-messages
          method: get
          request:
            parameters:
              querystrings:
                caseId: false
          cors: true
  deleteCaseMessage:
    name: LAMBDA_${self:service}_http_delete_case_message_${self:provider.stage}
    handler: handler.deleteCaseMessage
    events:
      - http:
          path: case-messages/{caseMessageId}
          method: delete
          request:
            parameters:
              paths:
                caseMessageId: true
          cors: true

resources:
  Resources:
    # CognitoUserPool:
    #   Type: "AWS::Cognito::UserPool"
    #   Properties:
    #     AliasAttributes:
    #       - preferred_username
    #     MfaConfiguration: OFF
    #     UserPoolName: ${self:service}-cognito-${self:provider.stage}
    #     Policies:
    #       PasswordPolicy:
    #         MinimumLength: 6
    #         RequireLowercase: False
    #         RequireNumbers: True
    #         RequireSymbols: False
    #         RequireUppercase: True
    # CognitoUserPoolClient:
    #   Type: "AWS::Cognito::UserPoolClient"
    #   Properties:
    #     ClientName: ${self:service}-cognito-client-${self:provider.stage}
    #     GenerateSecret: False
    #     UserPoolId:
    #       Ref: CognitoUserPool
    SocketsDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: connectionId
            AttributeType: S
          - AttributeName: userId
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: connectionId
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_SOCKETS_TABLE}
        GlobalSecondaryIndexes:
          - IndexName: ${self:provider.environment.DYNAMODB_SOCKETS_USER_GSI}
            KeySchema:
              - AttributeName: userId
                KeyType: HASH
            Projection:
              ProjectionType: ALL
    CaseDefinitionsDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_CASE_DEFINITIONS_TABLE}
    TaskDefinitionsDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_TASK_DEFINITIONS_TABLE}
    CasesDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: state
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_CASES_TABLE}
        GlobalSecondaryIndexes:
          - IndexName: ${self:provider.environment.DYNAMODB_CASES_ON_STATE_GSI}
            KeySchema:
              - AttributeName: state
                KeyType: HASH
            Projection:
              ProjectionType: ALL
    TasksDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: caseId
            AttributeType: S
          - AttributeName: state
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_TASKS_TABLE}
        GlobalSecondaryIndexes:
          - IndexName: ${self:provider.environment.DYNAMODB_TASKS_ON_CASE_GSI}
            KeySchema:
              - AttributeName: caseId
                KeyType: HASH
            Projection:
              ProjectionType: ALL
          - IndexName: ${self:provider.environment.DYNAMODB_TASKS_ON_STATE_GSI}
            KeySchema:
              - AttributeName: state
                KeyType: HASH
            Projection:
              ProjectionType: ALL
    CaseMessagesDynamoDbTable:
      Type: 'AWS::DynamoDB::Table'
      # For a production deployment, you'd want to retain your DB
      # in case of re-deployment or stack removal to avoid data loss.
      # DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: caseId
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        TableName: ${self:provider.environment.DYNAMODB_CASE_MESSAGES_TABLE}
        GlobalSecondaryIndexes:
          - IndexName: ${self:provider.environment.DYNAMODB_CASE_MESSAGES_CASEID_GSI}
            KeySchema:
              - AttributeName: caseId
                KeyType: HASH
            Projection:
              ProjectionType: ALL

  # Outputs:
  #   CognitoUserPoolId:
  #     Value:
  #       Ref: CognitoUserPool
  #     Export:
  #       Name: ASW-CognitoUserPoolId-${self:provider.stage}
  #   CognitoUserPoolClientId:
  #     Value:
  #       Ref: CognitoUserPoolClient
  #     Export:
  #       Name: ASW-CognitoUserPoolClientId-${self:provider.stage}
